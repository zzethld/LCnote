看到这题，第一反应就是最大堆。但是我不知道为什么对堆很恐惧，可能是因为知道自己并没有完全掌握吧？所以就用堆来解决这个题目

思路：最大堆，每次都Pop两个出来，将其个数减一再push回去。

模式匹配： 	相邻不同

我为什么没有想到：
	之前说一开始就想到了堆，其实也想过了这个方案，不过当时由于考虑了一下，每次都要pop,push太麻烦，就没有继续深入这个思路。
	
落地困难：
	完成时间：120min，这道题最主要是关于堆该怎么写不清楚，导致我花费了大量时间去学习堆的写法。（不过为什么会花费这么久的时间呢？当时Compare函数的写法让我看的很头痛，就不想去看，但是又得看，自己消极的态度导致花费时间暴增）还有一个就是，我其实是不想用pair的，我想使用另外的数组进行比较，哈哈，比较蠢。
	
反思：自己很怕遇到很麻烦或者说自己没有掌握的东西，很多思路其实都已经想到，不过因为怕麻烦就把该思路PASS掉了。而且自己在学习的时候，很怕遇到短时间没想懂的，没有很多耐心，我觉得这样不好，应该改正。

priority<数据类型,容器，比较方法> 后两个可以省略。
比较方法：
struct{
	bool operator()(参数A，参数B){
	return x;
	// if(false)
	//	交换； 我们是从末尾插入，如果为true就说明不用交换，即优先级较低。
	}
}；
		

