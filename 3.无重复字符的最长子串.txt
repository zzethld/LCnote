我觉得串的问题，大多都可以参考kmp算法的思想。

思路：
	依次判断，若有相同的回退到上一个该字符串出现的位置（即尽量少回退）。
	
模式匹配：
	最长连续子串 不重复
	即建立一个判断当前元素在当前串中是否重复的手段再加上一个回退规则。
	
我为什么能想到：
	和KMP很像，都是寻找某种连续子串。由于是连续串，建立回退规则，再通过判断手段来判断当前是否重复。
	
落地时的困难：
	这道题目的完成时间为25min。思路来的很快，不过最开始并没有考虑回退，只考虑了重复。而且将字符串当成了字母串，导致提交了几次错误代码。
	
总结：
	自己确实很菜，没有将情况考虑完。菜逼的大脑容量是有限的，应该把大纲写在纸上，这样对题对我都好。
	
核心代码：
	int time:当前判断串的次数，与后面的数组大小进行联动判断。
	int k[256]:将串int化，值为当前字符出现的时间。eg：k['a']=10 即a出现的时间为第5次串。
	判断是否重复： k[x] == time?
	回退 l[a]  l[a] = i;
//count:串长度，max：最长串长度
 for(int i = 0 ; i < n;){
            int a = (int)s[i];
            if(k[a] != time){
                k[a] = time;
                i++;
                count++;
            }else{
                if(count > max)
                max = count;
                time++;
                count = 0;
                i = l[a];

            }
            l[a] = i;
        }