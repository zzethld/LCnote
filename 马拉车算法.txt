马拉车算法:专门用于计算最长回文串的方法。O（n）
它就是个纸老虎，相信正常的同学一定都能很快理解。它并没有想象中的那么难以理解，甚至可以说算是比较容易理解的那一类。
我看了不少讲马拉松算法的文章，最开始也是一头雾水，直到我搞懂他的思想之后才猛然发现，原来如此简单。

马拉松算法和KMP算法很像，他们都是尽力对自身资源进行挖掘，使串少回退。
核心思路：利用回文串的对称性。在串内对称位置的点，回文数相同。注意：对称性！对称性！对称性！

代码可以自己实现，也并不困难，只需要考虑是否越界即可。
考虑到有A,AA，这两种中心点类型，我们设置了每个字符都插入一个通用字符，一般为'#'。eg： A -> #A#
i:当前位置  C: 串的中心点 R:串的回文半径 mirror:对称点 P[i]:该点回文半径
mirror = i - ( C - i ) =2i - C //对称点位置
 
while(i < n){
if(C + R < i) 		//生活总要继续
把当前点变成对称中心，并用传统方法计算当前点的回文半径。

else if(i + P[mirror] > n ) //超出字符串边界
P[i] = n - i;

else if(i + P[mirror] > C + R) //超出对称边界
把当前点变成对称中心，将半径设为(R - i)， 并从上一个对称中心的边界开始进行扩散

else if					//一般情况
P[i] = P[mirror]
}

