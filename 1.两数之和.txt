看到这题的第一反应是二分法，但转念一想，连续n/2次二分谁顶的住啊。后改为hash。


思路：
	建立hash表，直接查找即可。

模式匹配：
	查找区间内是否存在某数

我为什么能想到：
	读题可得，判断是否存在两个数相加为K，即可简化为存在nums[i]时判断k-nums[i]是否存在。由于需要返回下标，我们则使用unordered_map<值，下标>进行存储判断。
	
落地时的问题：
	这道题目的完成时间大概在15min。在看到题的一分钟以内已经清楚大体思路，后面时间的浪费主要是因为对unordered_map使用不熟悉造成的。而且也是由于在写代码之前没有写大纲造成的，导致写起来很不顺畅。还有在测试时没有考虑如果是两个一样的值该如何。

总结：凡事预则立不预则废，最好先写个思路大纲。而且对unordered_map使用并不熟练。测试时没有把情况测试完整，慌慌忙忙的就提交了，或者说在思考的时候并没有思考全面。

基础知识：unordered_map<key, value> p
如何添加项？ p[key] = value;
如何查找项？ 个数问题(int) p.count(key) ，返回值为个数。
			 值问题 p[key]= ， 不用p.find()，find返回的是迭代器？

核心代码：（略）此题考查点为hash表的使用。

疑惑：我之前用二分法写过，在测试的时候二分法的时间远远小于hash，我觉得很离谱。不知道有老板解惑没有。
