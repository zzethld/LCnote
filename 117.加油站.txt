在看到这道题的瞬间，我想起了另外一道加油的问题。而那一道题目标是最少的加油次数，这道题目标是从哪出发。
读完题之后，可以简化为：我们从0开始，从左到右有一个循环指针。每个节点上有一个整数，每次向右移动即将该节点上的整数相加，我们要让每次相加后的数都大于等于0，求出发节点。
思路：头尾指针。
先进行一次判定，若整体>=0则说明是可行的，若整体<0,则直接返回-1。
	若相加后<0，则头指针右移并减去头指针的值。
	若相加后>0，则尾指针右移，并加上尾指针的值。

模式匹配：

	这题可以理解为移动窗口的前缀值。
	前缀：累加 移动窗口：双指针。
	
我为什么能想到：			  	
	读题可得，我们可以从开头移动到某个位置（移动窗口），必定是之前每次都有充足的油（该点之前的前缀和都大于0）。

落地时的问题：	
	这道题目完成时间在25min，问题：我在开始想到思路后，就一直思考后续（我也不清楚思考了啥），没有将它落到笔尖。直接导致了10分钟左右的时间一直在发呆。

总结：
	答案在笔尖，光想是没什么用的。
	
	
核心代码：
//sum:整体大小   need[]:gas-cost  start/end:头尾指针 ansum:当前前缀和
if(sum < 0)
        return -1;
        else{
            while(end < n){
                if(ansum>=0){
                    ansum = ansum + need[end];
                    end++;
                }else {
                        if(start < end){
                    ansum = ansum - need[start];
                    start++;
                        }else{
                        ansum = 0;
                        }
                }
            }